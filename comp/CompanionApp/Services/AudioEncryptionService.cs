using System;
using System.Collections.Concurrent;
using System.Security.Cryptography;

namespace CompanionApp.Services;

/// <summary>
/// Provides per-frequency AES-256-GCM encryption and decryption of Opus audio payloads.
/// Keys are generated by the server and distributed via the TLS-secured WebSocket
/// control channel (included in the <c>join_ok</c> response).
///
/// Encrypted payload format: [12-byte nonce][ciphertext][16-byte GCM auth-tag]
///
/// The 8-byte packet header (freqId + sequence) remains in plaintext so the server
/// can route frames without decryption, preserving the existing relay architecture.
/// </summary>
public sealed class AudioEncryptionService
{
    private readonly ConcurrentDictionary<int, byte[]> _freqKeys = new();

    private const int NonceSize = 12; // AES-GCM standard nonce size (96 bits)
    private const int TagSize = 16;   // AES-GCM authentication tag size (128 bits)

    /// <summary>
    /// Overhead added to each encrypted payload: nonce + GCM tag.
    /// </summary>
    public const int EncryptionOverhead = NonceSize + TagSize; // 28 bytes

    // ----------------------------------------------------------------
    // Key management
    // ----------------------------------------------------------------

    /// <summary>
    /// Store a frequency encryption key received from the server.
    /// </summary>
    public void SetFreqKey(int freqId, byte[] key)
    {
        if (key == null || key.Length != 32)
            throw new ArgumentException("Frequency key must be exactly 32 bytes (AES-256).", nameof(key));
        _freqKeys[freqId] = key;
    }

    /// <summary>
    /// Store a frequency encryption key from a base64-encoded string.
    /// </summary>
    public void SetFreqKey(int freqId, string base64Key)
    {
        SetFreqKey(freqId, Convert.FromBase64String(base64Key));
    }

    /// <summary>
    /// Remove a frequency key (called when leaving a frequency).
    /// </summary>
    public void RemoveFreqKey(int freqId)
    {
        _freqKeys.TryRemove(freqId, out _);
    }

    /// <summary>
    /// Check whether a frequency has an encryption key stored.
    /// </summary>
    public bool HasKey(int freqId) => _freqKeys.ContainsKey(freqId);

    /// <summary>
    /// Clear all stored keys (called on disconnect / cleanup).
    /// </summary>
    public void ClearAllKeys()
    {
        _freqKeys.Clear();
    }

    // ----------------------------------------------------------------
    // Encrypt / Decrypt
    // ----------------------------------------------------------------

    /// <summary>
    /// Encrypt an Opus payload for a given frequency using AES-256-GCM.
    /// Returns <c>[12-byte nonce][ciphertext][16-byte GCM tag]</c>,
    /// or <c>null</c> if no key is available for the frequency.
    /// </summary>
    public byte[]? Encrypt(int freqId, byte[] opusData, int offset, int length)
    {
        if (!_freqKeys.TryGetValue(freqId, out var key)) return null;

        var nonce = new byte[NonceSize];
        RandomNumberGenerator.Fill(nonce);

        var ciphertext = new byte[length];
        var tag = new byte[TagSize];

        using var aes = new AesGcm(key, TagSize);
        aes.Encrypt(nonce, opusData.AsSpan(offset, length), ciphertext, tag);

        // Result layout: [nonce 12][ciphertext N][tag 16]
        var result = new byte[NonceSize + length + TagSize];
        nonce.CopyTo(result, 0);
        ciphertext.CopyTo(result, NonceSize);
        tag.CopyTo(result, NonceSize + length);

        return result;
    }

    /// <summary>
    /// Decrypt an encrypted audio payload for a given frequency.
    /// Input format: <c>[12-byte nonce][ciphertext][16-byte GCM tag]</c>.
    /// Returns the decrypted Opus data, or <c>null</c> on failure
    /// (wrong key, tampered data, or no key stored).
    /// </summary>
    public byte[]? Decrypt(int freqId, byte[] data, int offset, int length)
    {
        if (!_freqKeys.TryGetValue(freqId, out var key)) return null;
        if (length < NonceSize + TagSize + 1) return null; // need at least 1 byte of ciphertext

        var nonce = data.AsSpan(offset, NonceSize);
        var ciphertextLen = length - NonceSize - TagSize;
        var ciphertext = data.AsSpan(offset + NonceSize, ciphertextLen);
        var tag = data.AsSpan(offset + NonceSize + ciphertextLen, TagSize);

        var plaintext = new byte[ciphertextLen];
        try
        {
            using var aes = new AesGcm(key, TagSize);
            aes.Decrypt(nonce, ciphertext, tag, plaintext);
            return plaintext;
        }
        catch (CryptographicException)
        {
            // Decryption failed â€” wrong key, tampered data, or incompatible format
            return null;
        }
    }
}
